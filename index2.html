// ...existing code...
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tam GÃ¶lge LaboratuvarÄ± - AdÄ±m AdÄ±m Deney</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f172a;
            --primary: #38bdf8;
            --accent: #fde047;
            --axis-y: 250px;
            --success: #4ade80;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background-color: var(--bg-dark);
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
            aspect-ratio: 16 / 9;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            user-select: none;
        }

        /* ...existing code... (kept other styles) ... */

        /* SimÃ¼lasyon ElemanlarÄ± (responsive & center-anchored) */
        #light-beam-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .draggable {
            position: absolute;
            cursor: grab;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateX(-50%); /* left = center of element */
            box-sizing: border-box;
            touch-action: none;
        }
        .draggable:active { cursor: grabbing; }
        .active-step { outline: 4px solid var(--accent); outline-offset: 10px; border-radius: 10px; }

        /* IÅŸÄ±k kaynaÄŸÄ± (responsive size) */
        #flashlight {
            height: clamp(36px, 4.5vh, 60px);
            top: calc(var(--axis-y) - 3vh);
            /* left set by JS */
        }
        .f-body { width: clamp(30px, 4vw, 50px); height: 60%; background: #475569; border-radius: 6px 0 0 6px; }
        .f-head { width: clamp(18px, 2.5vw, 25px); height: 100%; background: #1e293b; border-radius: 4px; border-right: 4px solid #fde047; }

        /* Cisim (responsive) */
        #object{
            width: clamp(36px, 5.5vw, 60px);
            height: clamp(36px, 5.5vw, 60px);
            background: radial-gradient(circle at 30% 30%, #4ade80, #166534);
            border-radius: 50%;
            top: calc(var(--axis-y) - 3vh);
            /* left set by JS */
        }

        /* Ekran / Perde (responsive) */
        #screen-container {
            position: absolute;
            top: clamp(28px, 4vh, 50px);
            width: clamp(90px, 16vw, 200px);
            height: clamp(180px, 44vh, 420px);
            z-index: 5;
            perspective: 800px;
            /* left set by JS */
        }
        #screen-surface {
            width: 100%; height: 100%; background: #fff; border: 6px solid #1e1b4b;
            border-radius: 4px; display: flex; justify-content: center; align-items: center; overflow: hidden;
            transform: rotateY(-30deg); transform-origin: center right;
            box-shadow: -10px 10px 30px rgba(0,0,0,0.3);
        }

        /* GÃ¶lge */
        #shadow {
            background: rgba(0,0,0,0.96);
            border-radius: 50%;
            filter: blur(2px);
            flex-shrink: 0;
            transition: width 0.12s, height 0.12s;
            max-width: 100%;
            max-height: 100%;
        }

        .label {
            position: absolute; bottom: -3.2vh; left: 50%; transform: translateX(-50%);
            font-size: clamp(10px, 1.4vh, 12px); font-weight: 600; color: #94a3b8; text-transform: uppercase;
            background: rgba(15, 23, 42, 0.8); padding: 4px 8px; border-radius: 10px; white-space: nowrap;
        }

        /* ...existing responsive rules... */
    </style>
</head>
<body>

    <!-- ...existing markup... -->
    <div id="intro-overlay">
        <div class="intro-card">
            <h1 style="color: var(--primary); margin-bottom: 15px;">Tam GÃ¶lge LaboratuvarÄ±na HoÅŸ Geldin!</h1>
            <p style="font-size: 18px; line-height: 1.6;">
                <b>Deneyin AmacÄ±:</b> IÅŸÄ±k kaynaÄŸÄ±, opak cisim ve ekran arasÄ±ndaki mesafelerin, oluÅŸan tam gÃ¶lgenin boyutuna etkisini adÄ±m adÄ±m keÅŸfetmek.
            </p>
            <p style="opacity: 0.8;">HazÄ±rsan, gÃ¶zlem yapmaya baÅŸlayalÄ±m!</p>
            <button class="btn-start" onclick="startExperiment()">Hadi BaÅŸlayalÄ±m! ðŸš€</button>
        </div>
    </div>

    <div id="main-container" style="display: none;">
        <h2 id="step-title" style="color: var(--primary); font-size: 2.5vh; margin: 0;">AdÄ±m 1: IÅŸÄ±k KaynaÄŸÄ± Hreketinin GÃ¶lgeye Etkisi</h2>
        
        <div id="stage">
            <div id="evaluation-screen">
                <!-- ...existing content... -->
                <h1 style="color: var(--success); margin: 0;">ðŸ”¬ Deney SonuÃ§ Raporu</h1>
                <table class="result-table">
                    <tr><th>DeÄŸiÅŸken</th><th>YapÄ±lan Ä°ÅŸlem</th><th>GÃ¶lge Boyutu DeÄŸiÅŸimi</th></tr>
                    <tr><td>IÅŸÄ±k KaynaÄŸÄ±</td><td>Cisme YaklaÅŸÄ±rsa</td><td style="color: var(--success);">BÃ¼yÃ¼r â–²</td></tr>
                    <tr><td>Cisim</td><td>IÅŸÄ±k KaynaÄŸÄ±na YaklaÅŸÄ±rsa</td><td style="color: var(--success);">BÃ¼yÃ¼r â–²</td></tr>
                    <tr><td>Ekran (Perde)</td><td>Cisimden UzaklaÅŸÄ±rsa</td><td style="color: var(--success);">BÃ¼yÃ¼r â–²</td></tr>
                </table>
                <p style="text-align: center; max-width: 600px;">IÅŸÄ±k doÄŸrusal yayÄ±ldÄ±ÄŸÄ± iÃ§in engelin (cisim) Ä±ÅŸÄ±ÄŸa olan uzaklÄ±ÄŸÄ± veya ekranÄ±n konumu gÃ¶lgenin boyutunu doÄŸrudan etkiler.</p>
                <button class="btn-start" style="padding: 10px 30px;" onclick="location.reload()">Deneyi Tekrarla ðŸ”„</button>
            </div>

            <svg id="light-beam-svg">
                <defs>
                    <linearGradient id="beamGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(253, 224, 71, 0.4)" />
                        <stop offset="100%" style="stop-color:rgba(253, 224, 71, 0)" />
                    </linearGradient>
                </defs>
                <polygon id="beam-path" fill="url(#beamGrad)" />
            </svg>

            <div id="flashlight" class="draggable">
                <div class="f-body"></div><div class="f-head"></div>
                <span class="label">IÅŸÄ±k KaynaÄŸÄ±</span>
            </div>

            <div id="object" class="draggable">
                <span class="label">Opak Cisim</span>
            </div>

            <div id="screen-container" class="draggable">
                <div id="screen-surface">
                    <div id="shadow"></div>
                </div>
                <span class="label">Ekran (Perde)</span>
            </div>
        </div>

        <!-- ...existing panel ... -->
        <div id="step-panel">
            <div class="instruction-box">
                <div id="instruction-text">YÃ¼kleniyor...</div>
                <div class="nav-buttons">
                    <button id="btn1" class="btn-nav" onclick="setStep(1)">1. AdÄ±m</button>
                    <button id="btn2" class="btn-nav" onclick="setStep(2)">2. AdÄ±m</button>
                    <button id="btn3" class="btn-nav" onclick="setStep(3)">3. AdÄ±m</button>
                    <button id="btn4" class="btn-nav finish" onclick="setStep(4)">SONUÃ‡ ðŸ“‹</button>
                </div>
            </div>
            <div class="result-box">
                <div style="font-size: 14px; opacity: 0.7; margin-bottom: 5px;">BÄ°LÄ°MSEL SONUÃ‡:</div>
                <div id="result-text">Harekete geÃ§erek gÃ¶zlem yap!</div>
            </div>
        </div>
    </div>

    <script>
        // ...existing code...
        const flashlight = document.getElementById('flashlight');
        const object = document.getElementById('object');
        const screen = document.getElementById('screen-container');
        const shadow = document.getElementById('shadow');
        const beamPath = document.getElementById('beam-path');
        const evaluationScreen = document.getElementById('evaluation-screen');
        
        let currentStep = 1;
        let isDragging = false;
        let activeEl = null;

        // state.lx/ox/sx are center positions (px relative to #stage left)
        let state = { lx: null, ox: null, sx: null };

        const steps = {
            1: {
                title: "AdÄ±m 1: IÅŸÄ±k KaynaÄŸÄ± Hareketinin GÃ¶lgeye Etkisi",
                instruction: "Sadece Ä±ÅŸÄ±k kaynaÄŸÄ±nÄ± ileri ve geri hareket ettirerek gÃ¶lgedeki deÄŸiÅŸimi inceleyelim.",
                result: "IÅŸÄ±k kaynaÄŸÄ± cisme yaklaÅŸtÄ±ÄŸÄ±nda Ä±ÅŸÄ±nlar daha geniÅŸ aÃ§Ä±yla yayÄ±lÄ±r ve gÃ¶lge bÃ¼yÃ¼r. IÅŸÄ±k kaynaÄŸÄ± uzaklaÅŸtÄ±ÄŸÄ±nda ise gÃ¶lge kÃ¼Ã§Ã¼lÃ¼r.",
                target: flashlight
            },
            2: {
                title: "AdÄ±m 2: Cisim Hareketinin GÃ¶lgeye Etkisi",
                instruction: "Sadece yeÅŸil cismi Ä±ÅŸÄ±k kaynaÄŸÄ±na yaklaÅŸtÄ±rÄ±p uzaklaÅŸtÄ±rarak gÃ¶lgeyi gÃ¶zlemleyelim.",
                result: "Cisim Ä±ÅŸÄ±k kaynaÄŸÄ±na yaklaÅŸtÄ±ÄŸÄ±nda daha fazla Ä±ÅŸÄ±ÄŸÄ± engeller ve ekrandaki gÃ¶lge bÃ¼yÃ¼r. Cisim ekrana yaklaÅŸtÄ±ÄŸÄ±nda ise gÃ¶lge kÃ¼Ã§Ã¼lÃ¼r.",
                target: object
            },
            3: {
                title: "AdÄ±m 3: Ekran (Perde) Hareketinin GÃ¶Ã¶lgeye Etkisi",
                instruction: "Sadece beyaz ekranÄ± (perdeyi) cisme yaklaÅŸtÄ±rÄ±p uzaklaÅŸtÄ±rarak gÃ¶lge boyutunu gÃ¶zlemleyelim.",
                result: "Ekran cisimden uzaklaÅŸtÄ±kÃ§a Ä±ÅŸÄ±k Ä±ÅŸÄ±nlarÄ±nÄ±n yayÄ±ldÄ±ÄŸÄ± alan geniÅŸler ve gÃ¶lge bÃ¼yÃ¼r. Perde cisme yaklaÅŸtÄ±ÄŸÄ±nda gÃ¶lge kÃ¼Ã§Ã¼lÃ¼r.",
                target: screen
            },
            4: {
                title: "Deney TamamlandÄ±!",
                instruction: "Harika iÅŸ Ã§Ä±kardÄ±n! Åžimdi deney sonuÃ§larÄ±nÄ± aÅŸaÄŸÄ±daki sonuÃ§ kÄ±smÄ±ndan inceleyebilirsin.",
                result: "Deney baÅŸarÄ±yla tamamlandÄ±.",
                target: null
            }
        };

        function clamp(v, a, b){ return Math.min(Math.max(v, a), b); }

        function initStateIfNeeded() {
            const stage = document.getElementById('stage');
            const rect = stage.getBoundingClientRect();
            const stageW = rect.width;

            const fw = flashlight.offsetWidth || 50;
            const ow = object.offsetWidth || 50;
            const sw = screen.offsetWidth || 140;

            // sensible defaults if null
            if (state.lx === null) state.lx = Math.round(stageW * 0.08);
            if (state.ox === null) state.ox = Math.round(stageW * 0.5);
            if (state.sx === null) state.sx = Math.round(stageW * 0.82);

            // element center bounds
            const leftMin = Math.ceil(fw/2) + 8;
            const rightMax = Math.floor(stageW - sw/2) - 8;

            const minGapLO = Math.max(80, fw + 20);
            const minGapOS = Math.max(100, ow + 30);

            // enforce relational constraints
            state.lx = clamp(state.lx, leftMin, Math.max(leftMin, state.ox - minGapLO));
            state.ox = clamp(state.ox, state.lx + minGapLO, Math.max(state.lx + minGapLO, state.sx - minGapOS));
            state.sx = clamp(state.sx, state.ox + minGapOS, Math.max(state.ox + minGapOS, rightMax));
        }

        function updateScene() {
            const stage = document.getElementById('stage');
            const rect = stage.getBoundingClientRect();
            if (rect.width === 0) return;

            initStateIfNeeded();

            const fw = flashlight.offsetWidth || 50;
            const ow = object.offsetWidth || 50;
            const sw = screen.offsetWidth || 140;
            const stageH = rect.height;

            // apply positions (left is center due to translateX(-50%))
            flashlight.style.left = state.lx + "px";
            object.style.left = state.ox + "px";
            screen.style.left = state.sx + "px";

            // beam/shadow calculations relative to stage
            const centerY = stageH / 2;
            const fX = state.lx + fw * 0.3; // approximate light exit point
            const oX = state.ox;
            const sX = state.sx;
            const objR = Math.max(10, ow * 0.5);

            const distLO = Math.max(30, oX - fX);
            const distLS = Math.max(distLO + 20, sX - fX);

            let shadowH = (objR * 2 * distLS) / distLO;
            shadowH = Math.min(shadowH, stageH * 0.95);

            const shadowW = shadowH * 0.75;

            shadow.style.height = shadowH + "px";
            shadow.style.width = shadowW + "px";

            const sTopY = centerY - (shadowH / 2);
            const sBottomY = centerY + (shadowH / 2);

            beamPath.setAttribute("points", `${fX},${centerY} ${sX},${sTopY} ${sX},${sBottomY}`);
        }

        function setStep(n) {
            currentStep = n;
            document.querySelectorAll('.btn-nav').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn' + n); if(btn) btn.classList.add('active');
            document.getElementById('step-title').innerText = steps[n].title;
            document.getElementById('instruction-text').innerHTML = steps[n].instruction;
            document.getElementById('result-text').innerText = steps[n].result;

            if (n === 4) {
                evaluationScreen.style.display = 'flex';
                [flashlight, object, screen].forEach(el => el.classList.remove('active-step'));
            } else {
                evaluationScreen.style.display = 'none';
                [flashlight, object, screen].forEach(el => el.classList.remove('active-step'));
                if(steps[n].target) steps[n].target.classList.add('active-step');
            }
            
            updateScene();
        }

        function startExperiment() {
            document.getElementById('intro-overlay').style.display = 'none';
            document.getElementById('main-container').style.display = 'flex';
            // initialize positions based on current stage
            initStateIfNeeded();
            setStep(1);
        }

        function onStart(e) {
            if (currentStep === 4) return;
            const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
            const target = e.target.closest ? e.target.closest('.draggable') : null;
            if (target) {
                isDragging = true;
                activeEl = target;
                e.preventDefault();
            }
        }

        function onMove(e) {
            if (!isDragging || !activeEl) return;
            const stage = document.getElementById('stage');
            const rect = stage.getBoundingClientRect();
            const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
            let x = t.clientX - rect.left;
            // center-based coordinates because of translateX(-50%)
            const fw = flashlight.offsetWidth || 50;
            const ow = object.offsetWidth || 50;
            const sw = screen.offsetWidth || 140;

            const leftMin = Math.ceil(fw/2) + 8;
            const rightMax = Math.floor(rect.width - sw/2) - 8;

            const minGapLO = Math.max(80, fw + 20);
            const minGapOS = Math.max(100, ow + 30);

            if (activeEl === flashlight) {
                const maxL = state.ox - minGapLO;
                state.lx = clamp(x, leftMin, maxL);
            } else if (activeEl === object) {
                const minO = state.lx + minGapLO;
                const maxO = state.sx - minGapOS;
                state.ox = clamp(x, minO, maxO);
            } else if (activeEl === screen) {
                const minS = state.ox + minGapOS;
                const maxS = rightMax;
                state.sx = clamp(x, minS, maxS);
            }
            updateScene();
        }

        function onEnd() { isDragging = false; activeEl = null; }

        function onResize() {
            // recalc positions to stay inside stage after resize
            const stage = document.getElementById('stage');
            const rect = stage.getBoundingClientRect();
            if (rect.width === 0) return;
            initStateIfNeeded();
            updateScene();
        }

        window.addEventListener('mousedown', onStart);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onEnd);
        window.addEventListener('touchstart', onStart, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', onEnd);
        window.addEventListener('resize', onResize);

        // initial render (delay until layout calculated)
        window.requestAnimationFrame(updateScene);
    </script>
</body>
</html>
