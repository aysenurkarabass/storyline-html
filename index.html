<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tam G√∂lge ‚Äì Noktasal I≈üƒ±k</title>
<style>
* { box-sizing: border-box; }
body { 
  margin:0; 
  background:#accef0; 
  font-family:Arial;
  padding: 16px;
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:100vh;
}
.app{
  display:flex;
  flex-direction:column;
  gap:14px;
  align-items:stretch;
  max-width:1100px;
  margin:0 auto;
  padding:8px;
}
.top-controls, .position-controls{
  display:flex;
  gap:12px;
  align-items:center;
  justify-content: center;
  flex-wrap:nowrap;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  width:100%;
  background: linear-gradient(180deg,#f7fbfe,#eef7fc);
  padding:8px 12px;
  border-radius:8px;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
}
.overlay{
  position:fixed;
  inset:0;
  background:linear-gradient(180deg, rgba(6,12,34,0.55), rgba(6,12,34,0.65));
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:9999;
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);
}
.overlay-card{
  background: linear-gradient(180deg,#ffffff, #fbfdff);
  max-width:820px;
  width:92%;
  padding:26px;
  border-radius:14px;
  box-shadow:0 24px 60px rgba(2,6,23,0.45);
  color:#071023;
  transform-origin:center;
  animation: popIn 360ms ease both;
}
.overlay-card .hero{
  display:flex;
  gap:16px;
  align-items:center;
}
.overlay-card h1{ margin:0 0 6px 0; font-size:22px; }
.overlay-card .tag{ color:#0ea5a4; font-weight:700; font-size:13px; }
.overlay-card h2{ margin:8px 0 6px 0; font-size:16px; color:#0b1220; }
.overlay-card p, .overlay-card ul{ font-size:14px; line-height:1.6; color:#1f2937; }
.overlay-card ul{ padding-left:18px; margin:6px 0 0 0; }
.overlay-illustration{ width:140px; height:100px; flex:0 0 auto; }
.start-btn{ background: linear-gradient(90deg,#06b6d4,#0891b2); color:#fff; border:none; padding:12px 22px; border-radius:10px; font-weight:700; cursor:pointer; box-shadow:0 8px 20px rgba(3,105,161,0.18); }
.start-btn:hover{ transform:translateY(-2px); box-shadow:0 12px 28px rgba(3,105,161,0.2); }
.overlay-footer{ text-align:center; margin-top:14px; }

@keyframes popIn{ from{ transform: translateY(8px) scale(0.98); opacity:0 } to{ transform:none; opacity:1 } }
.position-controls .pos-control{
  display:flex;
  align-items:center;
  gap:8px;
  background: #ffffff;
  padding:6px 8px;
  border-radius:8px;
  box-shadow:0 6px 14px rgba(16,24,40,0.04);
  border:1px solid rgba(15,23,42,0.04);
  flex: 1 1 0;
  min-width: 0;
  max-width: calc((100% - 24px) / 3);
}
.pos-label{ font-weight:600; color:#0f172a; margin-right:8px; min-width:48px; text-align:left; }
.canvas-wrap{ width:100%; display:flex; justify-content:center; }
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  /* force stage aspect ratio 16:9 so canvas + controls fit inside */
  aspect-ratio: 16 / 9;
  max-height: 90vh;
  display:flex;
  flex-direction:column;
  gap:8px;
}
canvas {
  display:block;
  margin:auto;
  background:#f5f3f3;
  border:1px solid #000000;
  touch-action:none;
  width: 100%;
  height: 100%;
}
.position-controls .icon{
  display:none;
}
.top-controls{ background: linear-gradient(90deg,#4facfe,#00f2fe); color:#fff; }
.top-controls button{ background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.2); padding:8px 12px; border-radius:8px; transition: all 200ms ease; }
.top-controls button.active{ background:rgba(34,197,94,0.8); border-color:rgba(34,197,94,0.5); }
.top-controls label{ color:#fff; }

/* Slider base style */
input[type="range"]{
  -webkit-appearance:none;
  appearance:none;
  height:6px;
  border-radius:6px;
  background:#e6eef7;
  outline:none;
  margin:0;
  padding:0;
  width: clamp(180px, 35vw, 420px);
}
input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none;
  width:18px; height:18px; border-radius:50%; background:#fff; box-shadow:0 2px 6px rgba(0,0,0,0.2); border:3px solid #999;
}
input[type="range"]::-moz-range-thumb{ width:18px; height:18px; border-radius:50%; background:#fff; border:3px solid #999; }

/* Per-control colors */
#lightSlider{ background: linear-gradient(90deg,#fff3bf,#ffd166); }
#lightSlider::-webkit-slider-thumb{ border-color:#ffbf00; }
#objectSlider{ background: linear-gradient(90deg,#f0f4ff,#b8d0ff); }
#objectSlider::-webkit-slider-thumb{ border-color:#3b82f6; }
#screenSlider{ background: linear-gradient(90deg,#e6fff7,#bfffe0); }
#screenSlider::-webkit-slider-thumb{ border-color:#06b58b; }
.controls{
  width: 100%;
  max-width: 1000px;
  margin:6px auto;
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap: wrap;
  justify-content: center;
}
button{ 
  padding:6px 14px; 
  font-size:clamp(12px, 2vw, 14px);
  cursor: pointer;
  flex-shrink: 0;
}
label{ 
  font-size:clamp(12px, 2vw, 14px);
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}
input[type="range"] {
  width: 100%;
}

.position-controls .pos-control input[type="range"]{ width:100%; }

@media (max-width: 600px) {
  body { padding: 8px; align-items:flex-start; }
  .controls {
    gap: 6px;
  }
  .app{ flex-direction:column; }
  .top-controls, .position-controls{ padding:6px; }
  button {
    padding: 5px 10px;
  }
  input[type="range"] {
    width: 80px;
  }
}
</style>
</head>
<body>

<!-- Intro instruction overlay -->
<div id="introOverlay" class="overlay">
  <div class="overlay-card">
    <div class="hero">
      <div style="flex:1">
        <div class="tag"> <h1>Deney Adƒ±: Tam G√∂lge Olu≈üumu</h1></div>
        <h2>Deneyin Amacƒ±</h2>
        <p>Bu sim√ºlasyonda noktasal bir ƒ±≈üƒ±k kaynaƒüƒ±, bir cisim ve perde kullanƒ±larak tam g√∂lge olu≈üumu incelenecektir. Deney elamanlarƒ± farklƒ± konumlara getirilerek g√∂lgenin ≈üekli ve boyutu g√∂zlemlenecektir.</p>
        <h2>Nasƒ±l Kullanƒ±lƒ±r</h2>
        <ul>
          <li>Deney alanƒ±nƒ±n altƒ±ndaki kaydƒ±rƒ±cƒ± butonlar ile <strong>I≈üƒ±k</strong>, <strong>Cisim</strong> ve <strong>Perde</strong> yatay konumlarƒ±nƒ± ayarlayƒ±n.</li>
          <li>"Cisim Boyutu" ile cismin yarƒ±√ßapƒ±nƒ± (boyutunu) deƒüi≈ütirin.</li>
          <li>Kalem modunda ƒ±≈üƒ±k kaynaƒüƒ±ndan √ßƒ±kan ƒ±≈üƒ±nlarƒ± ekleyin; perde √ºzerinde olu≈üan g√∂lgeyi inceleyin.</li>
        </ul>
      </div>
      
    </div>

    <div class="overlay-footer">
      <button id="startBtn" class="start-btn">Hadi Ba≈ülayalƒ±m</button>
    </div>
  </div>
</div>


<div class="app">
  <div class="container">
    <div class="top-controls">
      <button id="penBtn">‚úèÔ∏è Kalem Modu</button>
      <button id="clearBtn">üßπ √áizgileri Temizle</button>
      <label>
        Cisim Boyutu
        <input type="range" id="sizeSlider" min="25" max="70" value="45">
      </label>
    </div>

    <div class="canvas-wrap">
      <canvas id="canvas" width="1000" height="450"></canvas>
    </div>

    <div class="position-controls">
      <label class="pos-control" title="I≈üƒ±k konumu">
        <span class="pos-label">I≈üƒ±k</span>
        <input type="range" id="lightSlider" min="0" max="1000" value="120" aria-label="I≈üƒ±k konumu">
      </label>

      <label class="pos-control" title="Cisim konumu">
        <span class="pos-label">Cisim</span>
        <input type="range" id="objectSlider" min="0" max="1000" value="400" aria-label="Cisim konumu">
      </label>

      <label class="pos-control" title="Perde konumu">
        <span class="pos-label">Perde</span>
        <input type="range" id="screenSlider" min="0" max="1000" value="760" aria-label="Perde konumu">
      </label>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let penMode=false, drawing=false, dragTarget=null, offsetX=0;
let rays=[];
let scale = 1;
let originalLight, originalObject, originalScreen;

// NESNELER (Orijinal deƒüerler - 1000x450 canvas i√ßin)
const light={x:120,y:225,r:6};
const object={x:400,y:225,r:45};
const screen={x:760,y:40,w:90,h:370};

originalLight = {...light};
originalObject = {...object};
originalScreen = {...screen};

// Canvas'ƒ± responsive yap (16:9 oranƒ±nda)
function resizeCanvas() {
  // Use the actual canvas bounding box so it always fits the 16:9 stage
  const rect = canvas.getBoundingClientRect();
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.width = Math.round(rect.width);
  canvas.height = Math.round(rect.height);
  // scale relative to design width (1000)
  scale = canvas.width / 1000;
  
  // Nesneleri √∂l√ßekle
  light.x = originalLight.x * scale;
  light.y = originalLight.y * scale;
  light.r = originalLight.r * scale;
  
  object.x = originalObject.x * scale;
  object.y = originalObject.y * scale;
  object.r = originalObject.r * scale;
  
  screen.x = originalScreen.x * scale;
  screen.y = originalScreen.y * scale;
  screen.w = originalScreen.w * scale;
  screen.h = originalScreen.h * scale;
  
  // Update sliders (if present) to reflect original coordinates
  const ls = document.getElementById('lightSlider');
  if(ls) ls.value = Math.round(originalLight.x);
  const os = document.getElementById('objectSlider');
  if(os) os.value = Math.round(originalObject.x);
  const ss = document.getElementById('screenSlider');
  if(ss) ss.value = Math.round(originalScreen.x);

  drawScene();
}

window.addEventListener('resize', resizeCanvas);
// Don't immediately show the simulation until user starts ‚Äî keep canvas sized but overlay visible
resizeCanvas();

// Intro overlay behavior
const introOverlay = document.getElementById('introOverlay');
const startBtn = document.getElementById('startBtn');
// draw schematic in intro SVG with correct rays/shadow (responsive)
function drawIntroSchematic(){
  const svg = document.getElementById('introSVG');
  if(!svg) return;
  const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { width:260, height:140 };
  const W = vb.width, H = vb.height;

  // positions as relative fractions so schematic is centered
  const L = { x: W * 0.12, y: H * 0.25 };
  const C = { x: W * 0.52, y: H * 0.55, r: Math.max(10, H * 0.12) };
  const screenCenterX = W * 0.85;
  const screenW = Math.max(8, W * 0.04);
  const screenH = Math.max(48, H * 0.6);
  const screenX = screenCenterX - screenW/2;
  const screenY = (H/2) - screenH/2;

  // compute tangent points from L to circle centered at C
  const dx = L.x - C.x, dy = L.y - C.y;
  const d = Math.hypot(dx,dy);
  if(d <= C.r + 0.1) return;
  const a = Math.atan2(dy, dx);
  const b = Math.acos(C.r / d);
  const t1 = a + b;
  const t2 = a - b;
  const tp1 = { x: C.x + C.r * Math.cos(t1), y: C.y + C.r * Math.sin(t1) };
  const tp2 = { x: C.x + C.r * Math.cos(t2), y: C.y + C.r * Math.sin(t2) };

  function extendToScreen(P){
    const x = screenCenterX;
    const y = L.y + ( (P.y - L.y) / (P.x - L.x) ) * (x - L.x);
    return { x, y };
  }
  const e1 = extendToScreen(tp1);
  const e2 = extendToScreen(tp2);

  const introLight = document.getElementById('introLight');
  const introObject = document.getElementById('introObject');
  const introScreen = document.getElementById('introScreen');
  const lightLabel = document.getElementById('introLightLabel');
  const objLabel = document.getElementById('introObjectLabel');
  const screenLabel = document.getElementById('introScreenLabel');
  const ray1 = document.getElementById('ray1');
  const ray2 = document.getElementById('ray2');
  const shadow = document.getElementById('introShadow');
  const helper = document.getElementById('helper1');

  if(introLight){ introLight.setAttribute('cx', L.x); introLight.setAttribute('cy', L.y); introLight.setAttribute('r', Math.max(6, H*0.07)); }
  if(lightLabel){ lightLabel.setAttribute('x', L.x); lightLabel.setAttribute('y', L.y + Math.max(26, H*0.2)); }

  if(introObject){ introObject.setAttribute('cx', C.x); introObject.setAttribute('cy', C.y); introObject.setAttribute('r', C.r); }
  if(objLabel){ objLabel.setAttribute('x', C.x); objLabel.setAttribute('y', C.y + C.r + 12); }

  if(introScreen){ introScreen.setAttribute('x', screenX); introScreen.setAttribute('y', screenY); introScreen.setAttribute('width', screenW); introScreen.setAttribute('height', screenH); }
  if(screenLabel){ screenLabel.setAttribute('x', screenCenterX); screenLabel.setAttribute('y', screenY + screenH + 12); }

  if(ray1){ ray1.setAttribute('x1', L.x); ray1.setAttribute('y1', L.y); ray1.setAttribute('x2', e1.x); ray1.setAttribute('y2', e1.y); }
  if(ray2){ ray2.setAttribute('x1', L.x); ray2.setAttribute('y1', L.y); ray2.setAttribute('x2', e2.x); ray2.setAttribute('y2', e2.y); }

  if(shadow){ const cy = (e1.y + e2.y)/2; const ry = Math.abs(e2.y - e1.y)/2; shadow.setAttribute('cx', screenCenterX); shadow.setAttribute('cy', cy); shadow.setAttribute('rx', Math.max(8, screenW*1.2)); shadow.setAttribute('ry', Math.max(6, ry)); }

  if(helper){ helper.setAttribute('x1', L.x); helper.setAttribute('y1', L.y); helper.setAttribute('x2', C.x); helper.setAttribute('y2', C.y); }
}
drawIntroSchematic();
window.addEventListener('resize', drawIntroSchematic);
if(startBtn){
  startBtn.onclick = () => {
    if(introOverlay) introOverlay.style.display = 'none';
    // ensure canvas resized for visible area
    resizeCanvas();
  };
}

// POSITION SLIDERS
const lightSlider = document.getElementById('lightSlider');
const objectSlider = document.getElementById('objectSlider');
const screenSlider = document.getElementById('screenSlider');

if(lightSlider){
  lightSlider.oninput = e => {
    originalLight.x = +e.target.value;
    light.x = originalLight.x * scale;
    drawScene();
  };
}
if(objectSlider){
  objectSlider.oninput = e => {
    originalObject.x = +e.target.value;
    object.x = originalObject.x * scale;
    drawScene();
  };
}
if(screenSlider){
  screenSlider.oninput = e => {
    originalScreen.x = +e.target.value;
    screen.x = originalScreen.x * scale;
    drawScene();
  };
}

// BUTONLAR
penBtn.onclick=()=>{
  penMode=!penMode;
  penBtn.classList.toggle('active', penMode);
};
clearBtn.onclick=()=>{rays=[];drawScene();};
sizeSlider.oninput=e=>{ originalObject.r=+e.target.value; object.r = originalObject.r * scale; drawScene(); };

// √áƒ∞Zƒ∞M
function drawScene(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // I≈ûIK PARILTI
  const glow=ctx.createRadialGradient(light.x,light.y,1,light.x,light.y,25*scale);
  glow.addColorStop(0,"rgba(255,220,100,0.9)");
  glow.addColorStop(1,"rgba(255,220,100,0)");
  ctx.fillStyle=glow;
  ctx.beginPath();
  ctx.arc(light.x,light.y,25*scale,0,Math.PI*2);
  ctx.fill();

  // I≈ûIK NOKTA
  ctx.fillStyle="#ffd000";
  ctx.beginPath();
  ctx.arc(light.x,light.y,light.r,0,Math.PI*2);
  ctx.fill();

  // Cƒ∞Sƒ∞M
  const grad=ctx.createRadialGradient(
    object.x-object.r/3,object.y-object.r/3,5*scale,
    object.x,object.y,object.r
  );
  grad.addColorStop(0,"#ddd");
  grad.addColorStop(1,"#555");
  ctx.fillStyle=grad;
  ctx.beginPath();
  ctx.arc(object.x,object.y,object.r,0,Math.PI*2);
  ctx.fill();

  // PERDE (GENƒ∞≈û & UZUN)
  const pgrad=ctx.createLinearGradient(screen.x+screen.w,0,screen.x,0);
  pgrad.addColorStop(0,"#cfe8f3");
  pgrad.addColorStop(1,"#7fb6d9");
  ctx.fillStyle=pgrad;
  ctx.beginPath();
  ctx.moveTo(screen.x+screen.w,screen.y);
  ctx.lineTo(screen.x,screen.y+25*scale);
  ctx.lineTo(screen.x,screen.y+screen.h-25*scale);
  ctx.lineTo(screen.x+screen.w,screen.y+screen.h);
  ctx.closePath();
  ctx.fill();

  // I≈ûINLAR
  ctx.strokeStyle="#000";
  ctx.lineWidth=2*scale;
  rays.forEach(r=>{
    ctx.beginPath();
    ctx.moveTo(r.start.x,r.start.y);
    ctx.lineTo(r.end.x,r.end.y);
    ctx.stroke();
  });

  if(rays.length===2) drawShadow();

  // ETƒ∞KETLER
  ctx.fillStyle="#000";
  ctx.font=`${14*scale}px Arial`;
  ctx.fillText("I≈üƒ±k",light.x-12*scale,light.y+22*scale);
  ctx.fillText("Cisim",object.x-18*scale,object.y+object.r+18*scale);
  ctx.fillText("Perde",screen.x+10*scale,screen.y+screen.h+20*scale);
}

// G√ñLGE ‚Äì TAM OTURAN ELƒ∞PS
function drawShadow(){
  const ys=rays.map(r=>{
    const t=(screen.x-r.start.x)/(r.end.x-r.start.x);
    return r.start.y+t*(r.end.y-r.start.y);
  });

  let top=Math.min(...ys);
  let bottom=Math.max(...ys);

  // PERDE ƒ∞√áƒ∞NE SIƒûDIR
  top=Math.max(top,screen.y);
  bottom=Math.min(bottom,screen.y+screen.h);

  const h=bottom-top;
  if(h<=0)return;

  ctx.fillStyle="rgba(0,0,0,0.35)";
  ctx.beginPath();
  ctx.ellipse(
    screen.x+screen.w/2,
    top+h/2,
    screen.w/2-8*scale,
    h/2,
    0,0,Math.PI*2
  );
  ctx.fill();
}

// MOUSE
canvas.onmousedown = e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left, y = e.clientY - r.top;

  // allow drawing rays in pen mode only; do not enable dragging of elements
  if (penMode && Math.hypot(x - light.x, y - light.y) < 10 && rays.length < 2) {
    drawing = true;
    rays.push({ start: { x: light.x, y: light.y }, end: { x, y } });
    return;
  }

  // no dragging: sliders control positions
};

canvas.onmousemove = e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left, y = e.clientY - r.top;

  if (drawing) {
    rays[rays.length - 1].end = { x, y };
    drawScene();
  }
  // dragging disabled ‚Äî sliders control element positions
};

canvas.onmouseup=()=>{drawing=false;dragTarget=null;};

drawScene();
</script>
</body>
</html>
